// the idea here is to perform a very basic form of parameter optimization for the game.
// we run the game without rendering, as fast as possible, and with randomized parameters.
// after some elapsed time, we evaluate the results keeping track of the best params.
// most of gym.go was generated by ChatGPT.
package main

import (
	"log"
	"slices"

	"github.com/rafibayer/ants-again/util"
)

const (
	// run for x simulated minutes
	GYM_SIM_TIME = 180 * TPS
	GYM_SAMPLES  = 4

	// concurrency controls
	GYM_PARAM_WORKERS  = 4 // how many different Params evaluated at once
	GYM_SAMPLE_WORKERS = 4 // how many samples per Params run concurrently
)

func runGym() error {
	type result struct {
		iteration int
		params    Params
		scores    []int
		stats     []Stats
		median    int
		medianSt  Stats
	}

	jobs := make(chan int)
	results := make(chan result)

	// --- param workers ---
	for w := 0; w < GYM_PARAM_WORKERS; w++ {
		go func() {
			for iteration := range jobs {
				params := Params{
					AntSpeed:                       util.Rand(0.5, 2.5),
					AntRotation:                    util.Rand(0.0, 20.0),
					AntPheromoneStart:              util.RandInt(5, 120),
					PheromoneSenseRadius:           util.Rand(GAME_SIZE/50, GAME_SIZE/4),
					PheromoneSenseCosineSimilarity: util.Rand(-1.0, 1.0),
					PheromoneDecay:                 float32(util.Rand(1/120.0, 1/1.0)),
					PheromoneDropProb:              util.Rand(1/180.0, 1/1.0),
					PheromoneInfluence:             util.Rand(0.1, 10.0),
					PheromoneSenseProb:             util.Rand(0.05, 1.0),
				}

				scores, stats := runSamples(params)
				median, medianSt := medianSample(scores, stats)

				results <- result{
					iteration: iteration,
					params:    params,
					scores:    scores,
					stats:     stats,
					median:    median,
					medianSt:  medianSt,
				}
			}
		}()
	}

	var bestCollected int
	var bestParams Params
	var bestStats Stats

	defer func() {
		log.Printf(
			"best: %d food collected\nparams: %#v\nstats: %#v",
			bestCollected, bestParams, bestStats,
		)
	}()

	// feed iterations
	go func() {
		for i := 0; ; i++ {
			jobs <- i
		}
	}()

	// collect results (single goroutine owns best state)
	for res := range results {
		if res.median > bestCollected {
			bestCollected = res.median
			bestParams = res.params
			bestStats = res.medianSt

			minScore := res.scores[0]
			maxScore := res.scores[0]
			for _, sc := range res.scores[1:] {
				if sc < minScore {
					minScore = sc
				}
				if sc > maxScore {
					maxScore = sc
				}
			}

			log.Printf("[%d] New Best: %d", res.iteration, res.median)
			log.Printf("[%d] Scores: min=%d median=%d max=%d",
				res.iteration, minScore, res.median, maxScore)
			log.Printf("Params: %#v", res.params)
			log.Printf("Stats (median sample): %#v", res.medianSt)
		}
	}

	return nil
}

func runSamples(params Params) ([]int, []Stats) {
	type sampleResult struct {
		score int
		stats Stats
	}

	work := make(chan struct{})
	out := make(chan sampleResult)

	// sample workers
	for w := 0; w < GYM_SAMPLE_WORKERS; w++ {
		go func() {
			for range work {
				game := NewGame(&params)

				for range GYM_SIM_TIME {
					if err := game.Update(); err != nil {
						log.Printf("error: %v\nparams: %#v", err, params)
					}
				}

				st := game.Stats()
				out <- sampleResult{
					score: st.food.collected,
					stats: *st,
				}
			}
		}()
	}

	// enqueue samples
	go func() {
		for i := 0; i < GYM_SAMPLES; i++ {
			work <- struct{}{}
		}
		close(work)
	}()

	scores := make([]int, 0, GYM_SAMPLES)
	stats := make([]Stats, 0, GYM_SAMPLES)

	for i := 0; i < GYM_SAMPLES; i++ {
		r := <-out
		scores = append(scores, r.score)
		stats = append(stats, r.stats)
	}

	return scores, stats
}

// medianSample returns the median score and the Stats belonging to
// the actual sample that produced that score.
func medianSample(scores []int, stats []Stats) (int, Stats) {
	type pair struct {
		val int
		idx int
	}

	n := len(scores)
	arr := make([]pair, n)
	for i, v := range scores {
		arr[i] = pair{v, i}
	}

	// sort by score only
	slices.SortFunc(arr, func(a, b pair) int {
		return a.val - b.val
	})

	mid := n / 2
	var medianIndex int
	var medianScore int

	if n%2 == 1 {
		medianScore = arr[mid].val
		medianIndex = arr[mid].idx
	} else {
		// average for median, pick upper-mid as representative
		medianScore = (arr[mid-1].val + arr[mid].val) / 2
		medianIndex = arr[mid].idx
	}

	return medianScore, stats[medianIndex]
}
